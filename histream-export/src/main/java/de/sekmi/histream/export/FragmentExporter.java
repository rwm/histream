package de.sekmi.histream.export;

import java.io.IOException;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLStreamException;
import javax.xml.xpath.XPath;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import de.sekmi.histream.ObservationException;
import de.sekmi.histream.export.config.Concept;
import de.sekmi.histream.export.config.ConceptGroup;
import de.sekmi.histream.export.config.ExportDescriptor;
import de.sekmi.histream.export.config.ExportException;

/**
 * Export visit fragments.
 * <p>
 * All {@link ObservationException}s generated by this class
 * are caused by either {@link ExportException} or {@link IOException}.
 * </p>
 *
 * @author R.W.Majeed
 *
 */
class FragmentExporter extends VisitFragmentParser {

	TableParser patientParser;
	TableParser visitParser;
	private Element currentPatient;
	private FactClassAnnotator factAnnotator;
	
	protected FragmentExporter(XPath xpath, ExportDescriptor desc, ExportWriter writer) throws ExportException, XMLStreamException, ParserConfigurationException {
		super();
		
		try {
			patientParser = desc.getPatientTable().createParser(writer.openPatientTable(), xpath);
			visitParser = desc.getVisitTable().createParser(writer.openVisitTable(), xpath);
		} catch (IOException e) {
			throw new ExportException("Unable to open table for writing", e);
		}
		// initialise annotator
		factAnnotator = new FactClassAnnotator();
		for( ConceptGroup group : desc.getConcepts().getGroups() ){
			String clazz = group.getClazz();
			for( Concept concept : group.getConcepts() ){
				String s = concept.getNotation();
				if( s != null ){
					factAnnotator.addMapRule(s, clazz);
					continue;
				}
				s = concept.getWildcardNotation();
				if( s != null ){
					if( s.indexOf('*') < s.length()-1 ){
						throw new ExportException("Wildcard notation '"+s+"' must contain exactly one * at the end");
					}
					factAnnotator.addWildcardRule(s.substring(0, s.length()-1), clazz);
					continue;
				}
				
				throw new ExportException("Group concepts must have one of 'notation' or 'wildcard-notation' defined. Concept IRI not supported yet");
			}
		}
	}

	@Override
	protected void patientFragment(Element patient) throws ObservationException {
		currentPatient = patient;
		try {
			patientParser.writeRow(patient);
		} catch (ExportException | IOException e) {
			throw new ObservationException(e);
		}
	}

	@Override
	protected void visitFragment(Element visit) throws ObservationException {
		// annotate facts with class attribute
		factAnnotator.annotateFacts(visit.getChildNodes());
		// move visit to patient
		// this allows XPath expressions to access the patient via
		// the parent element. E.g. '../@id' to get the patient id
		currentPatient.appendChild(visit);
		try {
			visitParser.writeRow(visit);
		} catch (ExportException | IOException e) {
			throw new ObservationException(e);
		} finally {
			// remove visit from patient
			currentPatient.removeChild(visit);
		}
		// TODO check for repeating concepts and write to separate parsers
	}

	@Override
	public void close(){
		super.close();
		try{
			patientParser.close();
		}catch( IOException e ){
			reportError(new ObservationException(e));
		}
		try{
			visitParser.close();
		}catch( IOException e ){
			reportError(new ObservationException(e));
		}
	}
}
